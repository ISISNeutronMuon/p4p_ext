"""
ISISServer is used to create PVs and manage their lifetimes
"""

import logging

from p4p import Value
from p4p.client.thread import Context
from p4p.server import Server, StaticProvider
from p4p.server.thread import SharedPV

from p4p_ext.pvrecipe import BasePVRecipe

from .utils import validate_pv_name

logger = logging.getLogger(__name__)


class NTServer:
    """
    Creates PVs and manages their lifetimes


    """

    def __init__(self, ioc_name: str, section: str, description: str, prefix="") -> None:
        """
        Initialize the ISIS Server instance.

        :param ioc_name: A PV naming convention compatible name for the IOC (Input/Output Controller).
        :param section:  The section or group responsible for the server e.g. Controls Software Applications, Diagnostics etc.
        :param description: A detailed description of the server and what it does.
        :param prefix: The prefix to be added to the PVs (Process Variables) of the server e.g. DEV: Defaults to "".
        """
        # provide information for IOC stats PVs
        self.ioc_name: str = ioc_name  #: The name of the IOC (Input/Output Controller).
        self.section: str = section  #: The section or group responsible for this server, e.g. Synch RF
        self.description: str = description  #: A description of the purpose of this server.
        # the prefix determines the prefix of the PVs to be added to the server e.g. DEV:
        self.prefix: str = prefix  #: The prefix to be prepended to the PVs generated by this server.

        self._provider = StaticProvider()
        self._server: Server | None = None
        self._pvs: dict[str, SharedPV] = {}

        self._running = False

        self._ctxt = Context("pva")

    def start(self) -> None:
        """Start the ISISServer"""

        # iterate over all the PVs and initialise them if they haven't
        # been already, add them to the provider and start the server
        # this means that PVs are only 'opened' and given a time stamp
        # at the time the server itself is started
        for pv_name, pv in self._pvs.items():
            self._provider.add(pv_name, pv)

        self._server = Server(providers=[self._provider])

        for pv_name, pv in self._pvs.items():
            for method in pv.on_start_methods:
                logger.debug("Applying on server start method for pv %s method %s", pv_name, method)
                method(server=self, pv_name=pv_name, pv=pv)

        logger.debug("Started Server with %s", self.pvlist)

        self._running = True

    def stop(self) -> None:
        """Stop the ISISServer"""

        # iterate over all the PVs and close them before removing them
        # from the provider and closing the server
        for pv_name, pv in self._pvs.items():
            pv.close()
            self._provider.remove(pv_name)
        if self._server:
            self._server.stop()
        logger.debug("\nStopped server")

        self._running = False

    def add_pv(self, pv_name: str, pv_recipe: BasePVRecipe) -> SharedPV:
        """
        Add a PV to the server

        :param pv_name: The name of the PV to be added.
        :param pv_recipe: The recipe with instructions for creating the PV.
        :return: The created PV.
        """

        if not pv_name.startswith(self.prefix):
            pv_name = self.prefix + pv_name
        pv_name = validate_pv_name(pv_name)
        returnval = self._pvs[pv_name] = pv_recipe.create_pv(pv_name)

        # If the server is already running then we need to add this PV to
        # the live system
        if self._running:
            self._provider.add(pv_name, returnval)
            logger.debug("Added %s to server", pv_name)

        return returnval

    def remove_pv(self, pv_name: str) -> None:
        """
        Remove a PV from the server

        :param pv_name: The name of the PV to be removed.
        :raises KeyError: If the PV is not found in the list managed by the server.
        """

        if not pv_name.startswith(self.prefix):
            pv_name = self.prefix + pv_name

        # TODO: Consider the implications if this throws an exception
        pv = self._pvs.pop(pv_name)
        pv.close()
        if self._running:
            # If the server is already running then we need to remove this PV
            # from the live system
            self._provider.remove(pv_name)
        logger.debug("Removed %s from server", pv_name)

    @property
    def pvlist(self) -> list[str]:
        """The PVs managed by the server"""
        return list(self._pvs.keys())

    def __getitem__(self, pv_name: str) -> SharedPV | None:
        """Return one of the PVs managed by the server given its name"""
        if not pv_name.startswith(self.prefix):
            pv_name = self.prefix + pv_name
        return self._pvs.get(pv_name)

    def get_pv_value(self, pv_name: str) -> Value:
        """
        Get the value of a PV using SharedPV.current() if the PV is on this server
        or Context.get() if it is not.
        """
        if pv_name in self.pvlist:
            logger.debug("Getting value using SharedPV for pv %s", pv_name)
            shared_pv = self._pvs.get(pv_name, None)
            if shared_pv:
                return shared_pv.current()

        logger.debug("Doing Context.get() for pv %s", pv_name)
        return self._ctxt.get(pv_name)  # type: ignore

    def put_pv_value(self, pv_name: str, value: Value):
        """
        Put the value to a PV using the server Context member self._ctxt
        """
        logger.debug("Trying putting value %r to pv %s", value, pv_name)
        self._ctxt.put(pv_name, value)
